<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChronoTime Mobile Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #map {
            height: 100vh;
            width: 100vw;
        }
        /* FORCE TUILES ULTRA-AGRESSIF */
        .leaflet-tile-pane,
        .leaflet-tile,
        .leaflet-tile img {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 1 !important;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script>
        // CARTE SIMPLE ET GARANTIE
        const map = L.map('map').setView([36.7538, 3.0588], 13);
        
        // OpenStreetMap SIMPLE
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // √âcouter les messages du parent
        window.addEventListener('message', function(event) {
            if (event.data.type === 'showRoute') {
                const { start, end, allPoints, sectors } = event.data;
                
                console.log('üì® Message re√ßu - affichage route:', start, end);
                console.log('üìç Points complets re√ßus:', allPoints);
                console.log('üåà Secteurs re√ßus:', sectors);
                
                // NETTOYAGE COMPLET AVANT NOUVEAU TRAC√â
                map.eachLayer(function(layer) {
                    if (layer instanceof L.Marker || layer instanceof L.Polyline) {
                        map.removeLayer(layer);
                        console.log('üßπ Couche supprim√©e');
                    }
                });
                
                // FORCE REFRESH TUILES AVANT AJOUT
                setTimeout(() => {
                    console.log('üîÑ Force refresh tuiles iframe...');
                    map.invalidateSize();
                    
                    // Ajouter marqueurs avec ic√¥nes color√©es
                    const startMarker = L.marker([start.lat, start.lng], {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map);
                    startMarker.bindPopup('üèÅ D√©part');
                    
                    const endMarker = L.marker([end.lat, end.lng], {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map);
                    endMarker.bindPopup('üèÜ Arriv√©e');
                    
                    // ROUTAGE LEAFLET NATIF - SANS CORS
                    console.log('üõ£Ô∏è Calcul route avec Leaflet Routing Machine...');
                    
                    try {
                        // UTILISER LEAFLET ROUTING MACHINE avec TOUS LES POINTS comme waypoints
                        const waypoints = allPoints.map(point => L.latLng(point.lat, point.lng));
                        console.log(`üó∫Ô∏è Cr√©ation route avec ${waypoints.length} waypoints`);
                        
                        const routingControl = L.Routing.control({
                            waypoints: waypoints,
                            routeWhileDragging: false,
                            addWaypoints: false,
                            createMarker: function() { return null; }, // Pas de marqueurs auto
                            lineOptions: {
                                styles: [{
                                    color: '#ff0000',
                                    weight: 5,
                                    opacity: 1
                                }]
                            },
                            show: false, // Masquer les instructions
                            collapsible: false
                        }).addTo(map);
                        
                        // Masquer le panneau d'instructions
                        const routingContainer = document.querySelector('.leaflet-routing-container');
                        if (routingContainer) {
                            routingContainer.style.display = 'none';
                        }
                        
                        // √âcouter quand la route est trouv√©e
                        routingControl.on('routesfound', function(e) {
                            const routes = e.routes;
                            if (routes && routes[0]) {
                                console.log('‚úÖ Route r√©elle calcul√©e avec', routes[0].coordinates.length, 'points');
                                
                                // APPLIQUER LES SECTEURS COLOR√âS (comme sur PC)
                                if (sectors && sectors.length > 0) {
                                    console.log('üåà Application des secteurs color√©s sur mobile...');
                                    
                                    // R√©cup√©rer les coordonn√©es du trac√© rout√© (comme sur PC)
                                    const routedPath = routes[0].coordinates;
                                    const totalPoints = routedPath.length;
                                    const sectorsCount = sectors.length;
                                    
                                    console.log(`üõ£Ô∏è Route: ${totalPoints} points, ${sectorsCount} secteurs`);
                                    
                                    // Masquer la route par d√©faut
                                    const routeLines = document.querySelectorAll('.leaflet-routing-container .leaflet-interactive');
                                    routeLines.forEach(line => {
                                        if (line.style) {
                                            line.style.opacity = '0';
                                        }
                                    });
                                    
                                    // Cr√©er des segments color√©s bas√©s sur les secteurs (SANS SUPERPOSITION)
                                    sectors.forEach((sector, index) => {
                                        const startRatio = index / sectorsCount;
                                        const endRatio = (index + 1) / sectorsCount;
                                        
                                        const startPointIndex = Math.floor(startRatio * totalPoints);
                                        let endPointIndex = Math.min(Math.floor(endRatio * totalPoints), totalPoints - 1);
                                        
                                        // √âviter les superpositions : le secteur suivant commence o√π le pr√©c√©dent finit
                                        if (index < sectorsCount - 1) {
                                            // Pas le dernier secteur : s'arr√™ter avant le prochain
                                            endPointIndex = Math.floor((index + 1) * totalPoints / sectorsCount);
                                        } else {
                                            // Dernier secteur : aller jusqu'au bout
                                            endPointIndex = totalPoints - 1;
                                        }
                                        
                                        // Extraire le segment du trac√© rout√© pour ce secteur
                                        const sectorPath = routedPath.slice(startPointIndex, endPointIndex + 1);
                                        
                                        if (sectorPath.length < 2) return;
                                        
                                        // Options optimis√©es pour mobile (comme PC)
                                        const coloredPolyline = L.polyline(sectorPath, {
                                            color: sector.color || '#FF0000',
                                            weight: 8, // Plus √©pais pour mobile
                                            opacity: 0.9,
                                            smoothFactor: 3, // Lissage accru sur mobile
                                            lineJoin: 'round',
                                            lineCap: 'round'
                                        }).addTo(map);
                                        
                                        // Ajouter un popup avec les infos du secteur (comme PC)
                                        coloredPolyline.bindPopup(`
                                            <div style="font-family: 'Teko', sans-serif; text-align: center;">
                                                <h4 style="color: ${sector.color}; margin: 5px 0;">${sector.name}</h4>
                                                <p style="margin: 3px 0; font-size: 0.9rem;">${sector.description}</p>
                                                <div style="background: ${sector.color}20; padding: 5px; border-radius: 5px; margin-top: 5px;">
                                                    <strong>Secteur ${sector.id}</strong>
                                                </div>
                                            </div>
                                        `);
                                        
                                        console.log(`üé® Secteur ${sector.id} appliqu√© en ${sector.color} (${sectorPath.length} points)`);
                                    });
                                    
                                    console.log(`üåà ${sectors.length} secteurs color√©s appliqu√©s avec succ√®s sur mobile!`);
                                }
                                
                                // Centrer sur la route
                                map.fitBounds(L.polyline(routes[0].coordinates).getBounds(), { padding: [30, 30] });
                                
                                console.log('‚úÖ Route r√©elle affich√©e avec Leaflet Routing');
                            }
                        });
                        
                        // Fallback si erreur
                        routingControl.on('routingerror', function(e) {
                            console.warn('‚ö†Ô∏è Erreur Leaflet Routing, fallback ligne droite');
                            
                            // Supprimer le routing control d√©faillant
                            map.removeControl(routingControl);
                            
                            // Ligne droite en fallback
                            const route = L.polyline([[start.lat, start.lng], [end.lat, end.lng]], {
                                color: '#ff0000',
                                weight: 5,
                                opacity: 1,
                                dashArray: '10, 10'
                            }).addTo(map);
                            
                            map.fitBounds(route.getBounds(), { padding: [30, 30] });
                        });
                        
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Leaflet Routing non disponible, ligne droite:', error);
                        
                        // FALLBACK FINAL - LIGNE DROITE
                        const route = L.polyline([[start.lat, start.lng], [end.lat, end.lng]], {
                            color: '#ff0000',
                            weight: 5,
                            opacity: 1,
                            dashArray: '10, 10'
                        }).addTo(map);
                        
                        map.fitBounds(route.getBounds(), { padding: [30, 30] });
                        console.log('‚û°Ô∏è Trac√© approximatif affich√©');
                    }
                    
                    console.log('‚úÖ Route compl√®te affich√©e dans iframe mobile');
                }, 200);
            }
        });
        
        console.log('‚úÖ Carte iframe mobile initialis√©e');
    </script>
</body>
</html>
