<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChronoTime Mobile Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #map {
            height: 100vh;
            width: 100vw;
        }
        /* FORCE TUILES ULTRA-AGRESSIF */
        .leaflet-tile-pane,
        .leaflet-tile,
        .leaflet-tile img {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 1 !important;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
    <script>
        // CARTE SIMPLE ET GARANTIE
        const map = L.map('map').setView([36.7538, 3.0588], 13);
        
        // OpenStreetMap SIMPLE
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // √âcouter les messages du parent
        window.addEventListener('message', function(event) {
            if (event.data.type === 'showRoute') {
                const { start, end, allPoints, sectors } = event.data;
                
                console.log('üì® Message re√ßu - affichage route:', start, end);
                console.log('üìç Points complets re√ßus:', allPoints);
                console.log('üåà Secteurs re√ßus:', sectors);
                
                // NETTOYAGE COMPLET AVANT NOUVEAU TRAC√â
                map.eachLayer(function(layer) {
                    if (layer instanceof L.Marker || layer instanceof L.Polyline) {
                        map.removeLayer(layer);
                        console.log('üßπ Couche supprim√©e');
                    }
                });
                
                // FORCE REFRESH TUILES AVANT AJOUT
                setTimeout(() => {
                    console.log('üîÑ Force refresh tuiles iframe...');
                    map.invalidateSize();
                    
                    // Ajouter marqueurs avec ic√¥nes color√©es
                    const startMarker = L.marker([start.lat, start.lng], {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map);
                    startMarker.bindPopup('üèÅ D√©part');
                    
                    const endMarker = L.marker([end.lat, end.lng], {
                        icon: L.icon({
                            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                            iconSize: [25, 41],
                            iconAnchor: [12, 41],
                            popupAnchor: [1, -34],
                            shadowSize: [41, 41]
                        })
                    }).addTo(map);
                    endMarker.bindPopup('üèÜ Arriv√©e');
                    
                    // AFFICHAGE SIMPLE DU TRAC√â GPS AVEC SECTEURS COLOR√âS
                    console.log('üó∫Ô∏è Affichage trac√© GPS avec secteurs color√©s...');
                    
                    // Cr√©er le trac√© GPS √† partir des points re√ßus
                    const gpsPath = allPoints.map(point => [point.lat, point.lng]);
                    console.log(`üìç Trac√© GPS: ${gpsPath.length} points`);
                    
                    if (sectors && sectors.length > 0) {
                        console.log(`üåà Application de ${sectors.length} secteurs color√©s...`);
                        
                        // Si on a peu de points GPS, on cr√©e un trac√© interpol√© pour avoir plus de segments
                        let displayPath = gpsPath;
                        if (gpsPath.length < 10) {
                            displayPath = [];
                            for (let i = 0; i < gpsPath.length - 1; i++) {
                                const start = gpsPath[i];
                                const end = gpsPath[i + 1];
                                
                                // Ajouter le point de d√©part
                                displayPath.push(start);
                                
                                // Interpoler 10 points entre start et end
                                for (let j = 1; j < 10; j++) {
                                    const ratio = j / 10;
                                    const interpolatedLat = start[0] + (end[0] - start[0]) * ratio;
                                    const interpolatedLng = start[1] + (end[1] - start[1]) * ratio;
                                    displayPath.push([interpolatedLat, interpolatedLng]);
                                }
                            }
                            // Ajouter le dernier point
                            displayPath.push(gpsPath[gpsPath.length - 1]);
                            console.log(`üìà Trac√© interpol√©: ${displayPath.length} points`);
                        }
                        
                        const totalPoints = displayPath.length;
                        const sectorsCount = sectors.length;
                        
                        // Appliquer chaque secteur color√©
                        sectors.forEach((sector, index) => {
                            const startRatio = index / sectorsCount;
                            const endRatio = (index + 1) / sectorsCount;
                            
                            const startPointIndex = Math.floor(startRatio * totalPoints);
                            const endPointIndex = Math.min(Math.floor(endRatio * totalPoints), totalPoints - 1);
                            
                            // Extraire le segment pour ce secteur
                            const sectorPath = displayPath.slice(startPointIndex, endPointIndex + 1);
                            
                            if (sectorPath.length >= 2) {
                                // Cr√©er la polyline color√©e
                                const coloredPolyline = L.polyline(sectorPath, {
                                    color: sector.color || '#FF0000',
                                    weight: 6,
                                    opacity: 0.9,
                                    smoothFactor: 1
                                }).addTo(map);
                                
                                // Popup avec infos du secteur
                                coloredPolyline.bindPopup(`
                                    <div style="text-align: center;">
                                        <h4 style="color: ${sector.color}; margin: 5px 0;">${sector.name}</h4>
                                        <p style="margin: 3px 0;">${sector.description}</p>
                                    </div>
                                `);
                                
                                console.log(`üé® Secteur ${sector.id} (${sector.name}) appliqu√© en ${sector.color}`);
                            }
                        });
                        
                        console.log(`‚úÖ ${sectors.length} secteurs color√©s affich√©s!`);
                    } else {
                        // Pas de secteurs, trac√© simple
                        L.polyline(gpsPath, {
                            color: '#FF0000',
                            weight: 5,
                            opacity: 0.8
                        }).addTo(map);
                        console.log('üìç Trac√© GPS simple affich√©');
                    }
                    
                    // Centrer la carte sur le trac√©
                    if (gpsPath.length > 0) {
                        map.fitBounds(L.polyline(gpsPath).getBounds(), { padding: [20, 20] });
                    }
                    
                    console.log('‚úÖ Trac√© affich√© avec succ√®s!');
                }, 200);
            }
        });
        
        console.log('‚úÖ Carte iframe mobile initialis√©e');
    </script>
</body>
</html>
